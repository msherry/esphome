esp32:
  board: nologo_esp32c3_super_mini
  variant: esp32c3
  framework:
    type: esp-idf

packages:
  device_base: !include _common.yaml

substitutions:
  update_interval: 3600s

esphome:
  on_boot:
    # If we woke up due to a button press, pulse the switch so the user knows we're doing something
    - lambda: |-
        if (esp_sleep_get_wakeup_cause() == ESP_SLEEP_WAKEUP_GPIO) {
          id(remote_light).turn_on().set_rgb(0.0, 0.0, 0.0).set_effect("Fast pulse").perform();
        }
    # Collect the wakeup reason upon first wakeup
    - sensor.template.publish:
        id: wakeup_cause
        state: !lambda return esp_sleep_get_wakeup_cause();
    # Duplicate it elsewhere so that we can munge it
    - sensor.template.publish:
        id: wakeup_cause_preserved
        state: !lambda return id(wakeup_cause).state;

wifi:
  power_save_mode: none
  output_power: 8.5dB           # helps with wifi auth errors, somehow
  fast_connect: true

api:
  on_client_connected:
    # Wait for home assistant to fully subscribe
    - delay: 5s
    - if:
        condition:
          lambda: |-
            // Mega hack, since the state_subscription_only flag is true on
            // non-HA connections, in contravention of the docs -- we ignore
            // connections from "ESPHome Logs 2025.12.0" and similar
            return id(api_id).is_connected(true) && client_info.find("Logs") == -1;
        then:
          - logger.log:
              level: DEBUG
              format: "HomeAssistant client %s connected to API with IP %s"
              args: ["client_info.c_str()", "client_address.c_str()"]
          # Use the stored wakeup reason, then clear it out to avoid issues with HA flapping
          - lambda: |-
              if (id(wakeup_cause).state == float(ESP_SLEEP_WAKEUP_TIMER)) {
                ESP_LOGD("sauna_remote", "Woke up via timer");
              } else if (id(wakeup_cause).state == float(ESP_SLEEP_WAKEUP_GPIO)) {
                ESP_LOGD("sauna_remote", "Woke up via GPIO, toggling sauna relay");
                id(sauna_outlet_switch).toggle();
              } else {
                ESP_LOGD("sauna_remote", "Woke up for some other reason (not %d or %d): %d",
                         ESP_SLEEP_WAKEUP_TIMER, ESP_SLEEP_WAKEUP_GPIO, id(wakeup_cause).state);
              }
          - logger.log:
              level: DEBUG
              format: "Clearing stored wakeup reason..."
          - sensor.template.publish:
              id: wakeup_cause
              state: -1
          - logger.log:
              level: DEBUG
              format: "Updating adc sensor..."
          - component.update: battery_adc
        else:
          - logger.log:
              level: DEBUG
              format: "NON HomeAssistant client %s connected to API with IP %s"
              args: ["client_info.c_str()", "client_address.c_str()"]


deep_sleep:
  id: deep_sleep_1
  # give enough time for HA to connect -- once connected, we will manually sleep
  run_duration: 10min
  sleep_duration: 10min
  wakeup_pin:
    # Tied to GPIO10, which is a pushbutton, and pulled high via *external*
    # resistor (so the voltage doesn't disappear on sleep)
    number: GPIO5
    inverted: true

output:
  - platform: ledc
    pin: GPIO1
    frequency: 1000 Hz
    id: red_output
    inverted: true
  - platform: ledc
    pin: GPIO3
    frequency: 1000 Hz
    id: green_output
    inverted: true
  - platform: ledc
    pin: GPIO4
    frequency: 1000 Hz
    id: blue_output
    inverted: true

light:
  - platform: rgb
    id: remote_light
    name: "Sauna remote light"
    red: red_output
    green: green_output
    blue: blue_output
    effects:
      - pulse:
          name: "Slow pulse"
          transition_length:
            on_length: 1000ms
            off_length: 800ms
          update_interval: 1800ms
      - pulse:
          name: "Fast pulse"
          transition_length:
            on_length: 400ms
            off_length: 400ms
          update_interval: 800ms
      - pulse:
          name: "Hyper pulse"
          transition_length:
            on_length: 200ms
            off_length: 200ms
          update_interval: 400ms

script:
  - id: handle_outlet_update
    # Allow later invocations to cancel earlier ones
    mode: restart
    then:
      - if:
          condition:
            lambda: return id(sauna_outlet_switch).state;
          then:
            - logger.log:
                level: DEBUG
                format: "Outlet active, preventing sleep"
            - deep_sleep.prevent: deep_sleep_1
          else:
            - logger.log:
                level: DEBUG
                format: "Outlet inactive, allowing sleep"
            - deep_sleep.allow: deep_sleep_1
            - delay: 15s
            - deep_sleep.enter: deep_sleep_1

switch:
  - platform: homeassistant
    name: "Sauna relay template switch"
    id: sauna_outlet_switch
    entity_id: "switch.sauna_outlet_switch_0"
    internal: true
    on_state:
      - script.execute: handle_outlet_update


binary_sensor:
  - platform: gpio
    name: "Button"
    pin:
      number: GPIO10
      mode: INPUT_PULLUP
      inverted: true          # pressed = ON when wired to GND + pull-up
    filters:
      - delayed_on: 20ms
      - delayed_off: 500ms
    on_press:
      - switch.toggle: sauna_outlet_switch

text_sensor:
  - platform: homeassistant
    name: "Sauna state"
    entity_id: sensor.sauna_state
    internal: true
    on_value:
      then:
        - lambda: |-
            auto call = id(remote_light).turn_on().set_effect("None");
            if (x == "Off") {
              // Replace the call with a new one
              call = id(remote_light).turn_off();
            } else if (x == "Warming") {
              call.set_rgb(1.0, 0.68, 0.0);
            } else if (x == "Ready") {
              call.set_rgb(1.0, 0.42, 0.0).set_effect("Slow pulse");
            } else if (x == "Idle") {
              call.set_rgb(0.2, 0.5, 0.0);
            } else if (x == "Disarmed?") {
              call.set_rgb(0.0, 0.79, 1.0).set_effect("Fast pulse");
            } else {
              ESP_LOGW("sauna", "Unknown state: %s", x.c_str());
              call.set_rgb(1.0, 0.2, 0.0).set_effect("Hyper pulse");
            }
            call.perform();

sensor:
  - platform: adc
    id: battery_adc
    pin: GPIO0
    name: "Battery ADC Raw"
    update_interval: never
    disabled_by_default: true
    attenuation: 12db
    sampling_mode: avg
    samples: 16
    on_value:
      component.update: battery_voltage

  - platform: template
    id: battery_voltage
    name: "Battery Voltage"
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    update_interval: never
    lambda: |-
      // Account for the 470k/330k voltage divider (Vbat = Vadc * (470k + 330k)/470k)
      return id(battery_adc).state * 1.702;
    filters:
      - clamp:
          min_value: 2.8
          max_value: 4.25
    on_value:
      component.update: battery_percentage

  - platform: template
    id: battery_percentage
    name: "Battery Percentage"
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    update_interval: never
    lambda: |-
      float v = id(battery_voltage).state;

      const float v_full = 4.20;   // full
      const float v_empty = 3.00;  // empty

      // Clamp measurable range
      if (v > v_full) v = v_full;
      else if (v < v_empty) v = v_empty;

      // Piecewise discharge curve (Li-ion 1S)
      // {voltage, percent}
      const float curve[][2] = {
        {3.00,   0},
        {3.30,  10},
        {3.42,  20},
        {3.50,  30},
        {3.62,  40},
        {3.70,  50},
        {3.78,  60},
        {3.85,  70},
        {3.98,  80},
        {4.10,  90},
        {4.20, 100}
      };

      // Iterate across points and interpolate
      for (int i = 0; i < (int)(sizeof(curve)/sizeof(curve[0])) - 1; i++) {
        float v_low = curve[i][0];
        float p_low = curve[i][1];
        float v_high  = curve[i+1][0];
        float p_high  = curve[i+1][1];

        if (v <= v_high) {
          // Linear interpolation
          float pct = p_low + (p_high - p_low) * ((v - v_low) / (v_high - v_low));
          return pct;
        }
      }

      // Fallback (should never hit)
      return 0.0;

      // Original, non-interpolated formula
      // return (v - v_empty) / (v_full - v_empty) * 100.0;

  - platform: template
    name: "Wakeup Cause"
    id: wakeup_cause
    disabled_by_default: true
    # internal: true
    accuracy_decimals: 0


  - platform: template
    name: "Wakeup Cause preserved"
    id: wakeup_cause_preserved
    disabled_by_default: true
    # internal: true
    accuracy_decimals: 0
