esp8266:
  board: d1_mini

packages:
  device_base: !include _common.yaml

wifi:
  power_save_mode: LIGHT

output:
  - platform: esp8266_pwm
    pin: D5
    frequency: 1000 Hz
    id: red_output
    inverted: true
  - platform: esp8266_pwm
    pin: D6
    frequency: 1000 Hz
    id: green_output
    inverted: true
  - platform: esp8266_pwm
    pin: D7
    frequency: 1000 Hz
    id: blue_output
    inverted: true

light:
  - platform: rgb
    id: remote_light
    name: "Sauna remote light"
    red: red_output
    green: green_output
    blue: blue_output
    effects:
      - pulse:
          name: "Slow pulse"
          transition_length:
            on_length: 1000ms
            off_length: 800ms
          update_interval: 1800ms
      - pulse:
          name: "Fast pulse"
          transition_length:
            on_length: 400ms
            off_length: 400ms
          update_interval: 800ms
      - pulse:
          name: "Hyper pulse"
          transition_length:
            on_length: 200ms
            off_length: 200ms
          update_interval: 400ms

binary_sensor:
  - platform: gpio
    name: "Button"
    pin:
      number: D2
      mode: INPUT_PULLUP
      inverted: true          # pressed = ON when wired to GND + pull-up
    filters:
      - delayed_on: 20ms
      - delayed_off: 500ms
    on_press:
      # - logger.log:
      #     level: INFO
      #     format: "Button pressed"
      - homeassistant.action:
          action: switch.toggle
          data:
            entity_id: "switch.sauna_outlet_switch_0"

text_sensor:
  - platform: homeassistant
    name: "Sauna state"
    entity_id: sensor.sauna_state
    internal: true
    on_value:
      then:
        # - logger.log:
        #     level: INFO
        #     format: "Remote sauna state received from HA: %s"
        #     args: ["x.c_str()"]
        - lambda: |-
            ESP_LOGI("sauna", "State changed: %s", x.c_str());
            auto call = id(remote_light).turn_on().set_effect("None");
            if (x == "Off") {
              // Replace the call with a new one
              call = id(remote_light).turn_off();
            } else if (x == "Warming") {
              call.set_rgb(1.0, 0.68, 0.0);
            } else if (x == "Ready") {
              call.set_rgb(1.0, 0.42, 0.0).set_effect("Slow pulse");
            } else if (x == "Idle") {
              call.set_rgb(0.2, 0.5, 0.0);
            } else if (x == "Disarmed?") {
              call.set_rgb(0.0, 0.79, 1.0).set_effect("Fast pulse");
            } else {
              ESP_LOGW("sauna", "Unknown state: %s", x.c_str());
              call.set_rgb(1.0, 0.2, 0.0).set_effect("Hyper pulse");
            }
            call.perform();

sensor:
  - platform: adc
    id: battery_adc
    pin: A0
    name: "Battery ADC Raw"
    update_interval: 21600s
    internal: false
    filters:
      - median:
          window_size: 5
          send_every: 1
          send_first_at: 1

  - platform: template
    id: battery_voltage
    name: "Battery Voltage"
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    update_interval: 21600s
    lambda: |-
      // Multiply by the combined divider compensation factor (external divider plus wemos d1 mini internal).
      return id(battery_adc).state * 5.07;

  - platform: template
    id: battery_percentage
    name: "Battery Percentage"
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    update_interval: 21600s
    lambda: |-
      float v = id(battery_voltage).state;

      const float v_full = 4.20;   // full
      const float v_empty = 3.00;  // empty

      if (v > v_full) v = v_full;
      else if (v < v_empty) v = v_empty;

      return (v - v_empty) / (v_full - v_empty) * 100.0;
    filters:
      - exponential_moving_average:
          alpha: 0.1
          send_every: 1
