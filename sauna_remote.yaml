esp8266:
  board: d1_mini

packages:
  device_base: !include _common.yaml

substitutions:
  update_interval: 3600s

esphome:
  on_boot:
    # work around https://github.com/esphome/feature-requests/issues/607
    # set a default value for the skip counter, otherwise it's nan
    - sensor.template.publish:
        id: battery_percentage_skips
        state: 0

wifi:
  power_save_mode: HIGH

output:
  - platform: esp8266_pwm
    pin: D5
    frequency: 1000 Hz
    id: red_output
    inverted: true
  - platform: esp8266_pwm
    pin: D6
    frequency: 1000 Hz
    id: green_output
    inverted: true
  - platform: esp8266_pwm
    pin: D7
    frequency: 1000 Hz
    id: blue_output
    inverted: true

light:
  - platform: rgb
    id: remote_light
    name: "Sauna remote light"
    red: red_output
    green: green_output
    blue: blue_output
    effects:
      - pulse:
          name: "Slow pulse"
          transition_length:
            on_length: 1000ms
            off_length: 800ms
          update_interval: 1800ms
      - pulse:
          name: "Fast pulse"
          transition_length:
            on_length: 400ms
            off_length: 400ms
          update_interval: 800ms
      - pulse:
          name: "Hyper pulse"
          transition_length:
            on_length: 200ms
            off_length: 200ms
          update_interval: 400ms

binary_sensor:
  - platform: gpio
    name: "Button"
    pin:
      number: D2
      mode: INPUT_PULLUP
      inverted: true          # pressed = ON when wired to GND + pull-up
    filters:
      - delayed_on: 20ms
      - delayed_off: 500ms
    on_press:
      # - logger.log:
      #     level: INFO
      #     format: "Button pressed"
      - homeassistant.action:
          action: switch.toggle
          data:
            entity_id: "switch.sauna_outlet_switch_0"

text_sensor:
  - platform: homeassistant
    name: "Sauna state"
    entity_id: sensor.sauna_state
    update_interval: 3600s
    internal: true
    on_value:
      then:
        # - logger.log:
        #     level: INFO
        #     format: "Remote sauna state received from HA: %s"
        #     args: ["x.c_str()"]
        - lambda: |-
            ESP_LOGI("sauna", "State changed: %s", x.c_str());
            auto call = id(remote_light).turn_on().set_effect("None");
            if (x == "Off") {
              // Replace the call with a new one
              call = id(remote_light).turn_off();
            } else if (x == "Warming") {
              call.set_rgb(1.0, 0.68, 0.0);
            } else if (x == "Ready") {
              call.set_rgb(1.0, 0.42, 0.0).set_effect("Slow pulse");
            } else if (x == "Idle") {
              call.set_rgb(0.2, 0.5, 0.0);
            } else if (x == "Disarmed?") {
              call.set_rgb(0.0, 0.79, 1.0).set_effect("Fast pulse");
            } else {
              ESP_LOGW("sauna", "Unknown state: %s", x.c_str());
              call.set_rgb(1.0, 0.2, 0.0).set_effect("Hyper pulse");
            }
            call.perform();

sensor:
  - platform: adc
    id: battery_adc
    pin: A0
    name: "Battery ADC Raw"
    update_interval: ${update_interval}
    disabled_by_default: true
    filters:
      - median:
          window_size: 5
          send_every: 1
          send_first_at: 1

  - platform: template
    id: battery_voltage
    name: "Battery Voltage"
    unit_of_measurement: "V"
    device_class: voltage
    state_class: measurement
    update_interval: ${update_interval}
    lambda: |-
      // Multiply by the combined divider compensation factor (external 100k plus wemos d1 mini 220k/100k divider).
      // Vbat = Vadc * (100k + 220k + 420k) / 100k = Vadc * 4.2
      return id(battery_adc).state * 4.2;

  - platform: template
    id: battery_percentage
    name: "Battery Percentage"
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    update_interval: ${update_interval}
    lambda: |-
      float v = id(battery_voltage).state;

      const float v_full = 4.20;   // full
      const float v_empty = 3.00;  // empty

      // Clamp measurable range
      if (v > v_full) v = v_full;
      else if (v < v_empty) v = v_empty;

      // Piecewise discharge curve (Li-ion 1S)
      // {voltage, percent}
      const float curve[][2] = {
        {3.00,   0},
        {3.30,  10},
        {3.42,  20},
        {3.50,  30},
        {3.62,  40},
        {3.70,  50},
        {3.78,  60},
        {3.85,  70},
        {3.98,  80},
        {4.10,  90},
        {4.20, 100}
      };

      // Iterate across points and interpolate
      for (int i = 0; i < (int)(sizeof(curve)/sizeof(curve[0])) - 1; i++) {
        float v_low = curve[i][0];
        float p_low = curve[i][1];
        float v_high  = curve[i+1][0];
        float p_high  = curve[i+1][1];

        if (v <= v_high) {
          // Linear interpolation
          float pct = p_low + (p_high - p_low) * ((v - v_low) / (v_high - v_low));
          return pct;
        }
      }

      // Fallback (should never hit)
      return 0.0;

      // Original, non-interpolated formula
      // return (v - v_empty) / (v_full - v_empty) * 100.0;
    filters:
      # work around https://github.com/esphome/feature-requests/issues/607
      # increment a skip counter, this skips the first N measurements
      - lambda: |-
          auto s = id(battery_percentage_skips);
          if (s->state > 1) { return x; }
          else { s->publish_state(s->state+1); return {}; }

      - exponential_moving_average:
          alpha: 0.1
          send_every: 1

  - platform: template
    id: battery_percentage_skips
    internal: true
    accuracy_decimals: 0
